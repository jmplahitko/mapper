"use strict";(self.webpackChunkdocumentations=self.webpackChunkdocumentations||[]).push([[6282],{9613:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return u}});var a=t(9496);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),s=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),c=s(t),u=r,g=c["".concat(l,".").concat(u)]||c[u]||m[u]||o;return t?a.createElement(g,i(i({ref:n},d),{},{components:t})):a.createElement(g,i({ref:n},d))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=c;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p.mdxType="string"==typeof e?e:r,i[1]=p;for(var s=2;s<o;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},7668:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return p},metadata:function(){return s},toc:function(){return m}});var a=t(5443),r=t(3010),o=(t(9496),t(9613)),i=["components"],p={id:"migrate-to-automapper-v8",title:"Migrating to AutoMapper 8",sidebar_label:"Migrating to AutoMapper 8",sidebar_position:2},l=void 0,s={unversionedId:"getting-started/migrate-to-automapper-v8",id:"getting-started/migrate-to-automapper-v8",title:"Migrating to AutoMapper 8",description:"Overview",source:"@site/docs/getting-started/migrate-v8.mdx",sourceDirName:"getting-started",slug:"/getting-started/migrate-to-automapper-v8",permalink:"/docs/getting-started/migrate-to-automapper-v8",draft:!1,editUrl:"https://github.com/nartc/mapper/tree/main/packages/documentations/docs/getting-started/migrate-v8.mdx",tags:[],version:"current",lastUpdatedBy:"Chau Tran",lastUpdatedAt:1648647558,formattedLastUpdatedAt:"3/30/2022",sidebarPosition:2,frontMatter:{id:"migrate-to-automapper-v8",title:"Migrating to AutoMapper 8",sidebar_label:"Migrating to AutoMapper 8",sidebar_position:2},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/getting-started/overview"},next:{title:"Installation",permalink:"/docs/getting-started/installation"}},d={},m=[{value:"Overview",id:"overview",level:2},{value:"Migrations",id:"migrations",level:2},{value:"<code>skipLibCheck</code>",id:"skiplibcheck",level:3},{value:"<code>createMapper(CreateMapperOptions)</code>",id:"createmappercreatemapperoptions",level:3},{value:"<code>createMap()</code>",id:"createmap",level:3},{value:"Syntax",id:"syntax",level:4},{value:"API",id:"api",level:4},{value:"<code>CreateMapOptions</code>",id:"createmapoptions",level:4},{value:"<code>addProfile()</code>",id:"addprofile",level:3},{value:"Syntax",id:"syntax-1",level:4},{value:"API",id:"api-1",level:4},{value:"<code>addTypeConverter()</code>",id:"addtypeconverter",level:3},{value:"<code>map()</code>",id:"map",level:3},{value:"Syntax",id:"syntax-2",level:4},{value:"API",id:"api-2",level:4},{value:"Mutation",id:"mutation",level:5},{value:"Extra Arguments",id:"extra-arguments",level:5},{value:"<code>MemberMapFunctions</code>",id:"membermapfunctions",level:3},{value:"<code>convertUsing</code>",id:"convertusing",level:4},{value:"Strategy (previously Plugin)",id:"strategy-previously-plugin",level:2},{value:"<code>@automapper/classes</code>",id:"automapperclasses",level:2},{value:"Initializer",id:"initializer",level:3},{value:"<code>AutoMap</code>",id:"automap",level:3},{value:"<code>@automapper/pojos</code>",id:"automapperpojos",level:2},{value:"Initializer",id:"initializer-1",level:3},{value:"<code>createMetadataMap()</code>",id:"createmetadatamap",level:3},{value:"NestJS",id:"nestjs",level:2},{value:"<code>AutomapperModule.forRoot</code>",id:"automappermoduleforroot",level:3},{value:"<code>AutomapperModule.forRootAsync</code>",id:"automappermoduleforrootasync",level:3},{value:"<code>AutomapperProfile</code>",id:"automapperprofile",level:3},{value:"<code>MapPipe</code>",id:"mappipe",level:3},{value:"<code>MapInterceptor</code>",id:"mapinterceptor",level:3}],c={toc:m};function u(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"In AutoMapper 8, the overall APIs of AutoMapper have changed from ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fluent_interface"},"Fluent API")," to a more ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Functional_programming"},"Functional")," approach. AutoMapper 8 also adopts the term ",(0,o.kt)("strong",{parentName:"p"},"Mapping Strategy")," (Strategy) to replace ",(0,o.kt)("strong",{parentName:"p"},"Mapping Plugin")," (Plugin). Strategy API is drastically simplified and made consistent across all Strategies."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before: Plugin Initializer sometimes is a function, other times is a function that needs to be invoked\nconst mapperOptions = {\n    // pluginInitializer: classes\n    // pluginInitializer: pojos\n    // pluginInitializer: mikro()\n    // pluginInitializer: sequelize()\n};\n\n// after: All Strategies are functions that need to be invoked\nconst mapperOptions = {\n    // strategyInitializer: classes()\n    // strategyInitializer: pojos()\n    // strategyInitializer: mikro()\n    // strategyInitializer: sequelize()\n};\n")),(0,o.kt)("h2",{id:"migrations"},"Migrations"),(0,o.kt)("h3",{id:"skiplibcheck"},(0,o.kt)("inlineCode",{parentName:"h3"},"skipLibCheck")),(0,o.kt)("p",null,"If you haven't had ",(0,o.kt)("inlineCode",{parentName:"p"},"skipLibCheck: true")," in your ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," already, go ahead and do so."),(0,o.kt)("h3",{id:"createmappercreatemapperoptions"},(0,o.kt)("inlineCode",{parentName:"h3"},"createMapper(CreateMapperOptions)")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"CreateMapperOptions")," no longer requires a ",(0,o.kt)("inlineCode",{parentName:"li"},"name")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"CreateMapperOptions")," accepts ",(0,o.kt)("inlineCode",{parentName:"li"},"strategyInitializer")," instead of ",(0,o.kt)("inlineCode",{parentName:"li"},"pluginInitializer"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nconst mapper = createMapper({\n    name: 'arbitrary',\n    pluginInitializer: classes,\n    /* namingConventions and errorHandler stay the same */\n});\n\n// after\nconst mapper = createMapper({\n    strategyInitializer: classes(),\n    /* namingConventions and errorHandler stay the same */\n});\n")),(0,o.kt)("h3",{id:"createmap"},(0,o.kt)("inlineCode",{parentName:"h3"},"createMap()")),(0,o.kt)("p",null,"Previously, ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()")," was a method available on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," object (returned by ",(0,o.kt)("inlineCode",{parentName:"p"},"createMapper()"),"). Now, ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()")," is a standalone function instead."),(0,o.kt)("h4",{id:"syntax"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper.createMap(User, UserDto);\n\n// after\ncreateMap(mapper, User, UserDto);\n")),(0,o.kt)("h4",{id:"api"},"API"),(0,o.kt)("p",null,"Previously, ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.createMap()")," returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"CreateMapFluentFunctions")," which allows you to chain ",(0,o.kt)("inlineCode",{parentName:"p"},"forMember()")," and other methods to customize the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapping")," you are creating. Now, ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()")," returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapping")," itself. Customization is provided by using other standalone functions. In AutoMapper 8, we call these functions ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingConfiguration"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper\n    .createMap(User, UserDto)\n    .forMember(/* ... */)\n    .forSelf(/* ... */)\n    .beforeMap(/* ... */)\n    .afterMap(/* ... */);\n\n// after\ncreateMap(\n    mapper,\n    User,\n    UserDto,\n    forMember(/* ... */),\n    forSelf(/* ... */),\n    beforeMap(/* ... */),\n    afterMap(/* ... */)\n);\n")),(0,o.kt)("p",null,"This Functional API allows for better tree-shaking and grouping ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingConfiguration")," into reusable functions that you can use on different ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()"),"."),(0,o.kt)("h4",{id:"createmapoptions"},(0,o.kt)("inlineCode",{parentName:"h4"},"CreateMapOptions")),(0,o.kt)("p",null,"Previously, you can pass in a ",(0,o.kt)("inlineCode",{parentName:"p"},"CreateMapOptions")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.createMap()"),". Now, those options are provided by different\nstandalone ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingConfiguration")," as well."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper.createMap(Base, BaseDto);\nmapper.createMap(User, UserDto, {\n    extend: [mapper.getMapping(Base, BaseDto)],\n    namingConventions: new PascalCaseNamingConvention(),\n});\n\n// after\nconst baseMapping = createMap(mapper, Base, BaseDto);\ncreateMap(\n    mapper,\n    User,\n    UserDto,\n    extend(baseMapping),\n    // or you can call: extend(Base, BaseDto)\n    namingConventions(new PascalCaseNamingConvention())\n);\n")),(0,o.kt)("h3",{id:"addprofile"},(0,o.kt)("inlineCode",{parentName:"h3"},"addProfile()")),(0,o.kt)("p",null,"Same as ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"addProfile()")," was a method on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," in previous versions. Now, ",(0,o.kt)("inlineCode",{parentName:"p"},"addProfile()")," is a standalone function"),(0,o.kt)("h4",{id:"syntax-1"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper.addProfile(productProfile).addProfile(userProfile);\n\n// after\naddProfile(mapper, productProfile);\naddProfile(mapper, userProfile);\n")),(0,o.kt)("h4",{id:"api-1"},"API"),(0,o.kt)("p",null,"Previously, ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.addProfile()")," returns the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," so you can chain ",(0,o.kt)("inlineCode",{parentName:"p"},"addProfile()"),". Now, ",(0,o.kt)("inlineCode",{parentName:"p"},"addProfile()")," is a ",(0,o.kt)("inlineCode",{parentName:"p"},"void")," function. The main difference is ",(0,o.kt)("inlineCode",{parentName:"p"},"addProfile()")," now accepts a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingConfiguration")," as well. The idea is you can have common ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingConfiguration")," that you can pass to ALL the ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()")," inside of a particular ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingProfile"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nconst productProfile: MappingProfile = (mapper) => {\n    const baseMapping = mapper.getMapping(Base, BaseDto);\n    const camelCaseConvention = new CamelCaseNamingConvention();\n\n    const beforeMap = () => {\n        /* do something common for all Mappings */\n    };\n    const afterMap = () => {\n        /* do something common for all Mappings */\n    };\n\n    // duplicate the configurations for all Mappings\n    mapper\n        .createMap(Product, ProductDto, {\n            extend: [baseMapping],\n            namingConventions: camelCaseConvention,\n        })\n        .beforeMap(beforeMap)\n        .afterMap(afterMap);\n\n    mapper\n        .createMap(Product, ProductDetailDto, {\n            extend: [baseMapping],\n            namingConventions: camelCaseConvention,\n        })\n        .beforeMap(beforeMap)\n        .afterMap(afterMap);\n\n    mapper\n        .createMap(Product, MinimalProductDto, {\n            extend: [baseMapping],\n            namingConventions: camelCaseConvention,\n        })\n        .beforeMap(beforeMap)\n        .afterMap(afterMap);\n};\nmapper.addProfile(productProfile);\n\n// after\nconst productProfile: MappingProfile = (mapper) => {\n    createMap(mapper, Product, ProductDto);\n    createMap(mapper, Product, ProductDetailDto);\n    createMap(mapper, Product, MinimalProductDto);\n};\n\n// pass the common configurations to the profile\naddProfile(\n    mapper,\n    productProfile,\n    extend(Base, BaseDto),\n    namingConventions(new CamelCaseNamingConvention()),\n    beforeMap(() => {\n        /* do something common for all Mappings */\n    }),\n    afterMap(() => {\n        /* do something common for all Mappings */\n    })\n);\n")),(0,o.kt)("p",null,"AutoMapper 8 version is cleaner. How it works is each ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingProfile")," has a ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingProfileContext")," created upon invoked. All the ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()")," inside a particular ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingProfile")," has access to that ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingProfileContext")," which includes all the common ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingConfiguration"),"."),(0,o.kt)("h3",{id:"addtypeconverter"},(0,o.kt)("inlineCode",{parentName:"h3"},"addTypeConverter()")),(0,o.kt)("p",null,"Previously, ",(0,o.kt)("inlineCode",{parentName:"p"},"addTypeConverter()")," is a method on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," object that allows you to create a converter between two types. The type converter then gets applied to every pair of properties that match the two types. However, type converters added by ",(0,o.kt)("inlineCode",{parentName:"p"},"addTypeConverter")," will be applied for ",(0,o.kt)("strong",{parentName:"p"},"ALL")," mappings, and that might not be the case."),(0,o.kt)("p",null,"In AutoMapper 8, ",(0,o.kt)("inlineCode",{parentName:"p"},"typeConverter()")," is a ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingConfiguration")," function that can be passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()")," (to configure for that ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapping"),") or ",(0,o.kt)("inlineCode",{parentName:"p"},"addProfile()")," (to configure for all mappings inside a ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingProfile"),"). There is no equivalence to ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," level type converters in AutoMapper 8."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper.addTypeConverter(String, Number, (str) => parseInt(str));\n\nmapper.createMap(User, UserDto);\nmapper.createMap(Product, ProductDto);\n\n// after\ncreateMap(\n    mapper,\n    User,\n    UserDto,\n    typeConverter(String, Number, (str) => parseInt(str))\n);\ncreateMap(\n    mapper,\n    Product,\n    ProductDto,\n    typeConverter(String, Number, (str) => parseInt(str) + 10)\n);\n")),(0,o.kt)("h3",{id:"map"},(0,o.kt)("inlineCode",{parentName:"h3"},"map()")),(0,o.kt)("h4",{id:"syntax-2"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper.map(user, UserDto, User);\n\n// after\nmapper.map(user, User, UserDto);\n")),(0,o.kt)("p",null,"This is a subtle breaking change that I've been holding off for a while. The positional arguments for ",(0,o.kt)("inlineCode",{parentName:"p"},"Source")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Destination"),' are now switched to be more logical: "I want to map ',(0,o.kt)("inlineCode",{parentName:"p"},"sourceObject")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"Source")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Destination"),'". This particularly makes it less confusing for ',(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/pojos")," users."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper.map<User, UserDto>(user, 'UserDto', 'User'); // weird order\n\n// after\nmapper.map<User, UserDto>(user, 'User', 'UserDto'); // matching order\n")),(0,o.kt)("h4",{id:"api-2"},"API"),(0,o.kt)("h5",{id:"mutation"},"Mutation"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"mutation")," API of ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.map()")," has been separated into a whole set of methods on ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.mutate()"),". This is to create a clear distinction between ",(0,o.kt)("inlineCode",{parentName:"p"},"mapping")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mutating"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nconst destinationObj = {};\nmapper.map(sourceObj, Destination, Source, destinationObj);\n\n// after\nconst destinationObj = {};\nmapper.mutate(sourceObj, destinationObj, Source, Destination);\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.mutate()")," family has matching APIs with ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.map()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"mapper.map();\nmapper.mapAsync();\nmapper.mapArray();\nmapper.mapArrayAsync();\n\nmapper.mutate();\nmapper.mutateAsync();\nmapper.mutateArray();\nmapper.mutateArrayAsync();\n")),(0,o.kt)("h5",{id:"extra-arguments"},"Extra Arguments"),(0,o.kt)("p",null,"When invoking a map operation with ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.map()"),", you have the ability to pass in a ",(0,o.kt)("inlineCode",{parentName:"p"},"MapOptions")," object with a property called: ",(0,o.kt)("inlineCode",{parentName:"p"},"extraArguments"),". This is to allow for passing in dynamic arguments (that are only available at the time the map is invoked) to a particular map operation."),(0,o.kt)("p",null,"In AutoMapper 8, ",(0,o.kt)("inlineCode",{parentName:"p"},"extraArguments")," has been renamed to ",(0,o.kt)("inlineCode",{parentName:"p"},"extraArgs")," and is a ",(0,o.kt)("inlineCode",{parentName:"p"},"Function")," instead of just a ",(0,o.kt)("inlineCode",{parentName:"p"},"Record<string, unknown>"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nmapper.map(user, UserDto, User, { extraArguments: { extra: 123 } });\n\n// after\nmapper.map(user, User, UserDto, {\n    extraArgs: (mapping, destinationObject) => ({ extra: 123 }),\n});\n")),(0,o.kt)("p",null,"With ",(0,o.kt)("inlineCode",{parentName:"p"},"extraArgs")," being a function, you will have all the information you need to return a more sophisticated ",(0,o.kt)("strong",{parentName:"p"},"extra arguments object"),". In addition to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"sourceObject")," that you already have access to (eg: ",(0,o.kt)("inlineCode",{parentName:"p"},"mapper.map(sourceObject, ...)"),"), ",(0,o.kt)("inlineCode",{parentName:"p"},"extraArgs")," is called with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapping")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"destinationObject"),", which you don't ",(0,o.kt)("em",{parentName:"p"},"easily")," have access to."),(0,o.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},(0,o.kt)("inlineCode",{parentName:"p"},"destinationObject")," might ",(0,o.kt)("strong",{parentName:"p"},"not")," be the complete destination object because it might be a particular property's turn with ",(0,o.kt)("inlineCode",{parentName:"p"},"mapWithArguments"),"."))),(0,o.kt)("h3",{id:"membermapfunctions"},(0,o.kt)("inlineCode",{parentName:"h3"},"MemberMapFunctions")),(0,o.kt)("h4",{id:"convertusing"},(0,o.kt)("inlineCode",{parentName:"h4"},"convertUsing")),(0,o.kt)("p",null,"The 2nd argument (",(0,o.kt)("inlineCode",{parentName:"p"},"Selector"),") is now required."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nconst dateToStringConverter: Converter<User, string> = {\n    convert(source: User): string {\n        return source.birthday.toDateString();\n    },\n};\nmapper.createMap(User, UserDto).forMember(\n    (d) => d.birthday,\n    // 2nd argument is optional.\n    // If not passed in, convertUsing will call the converter#convert with the whole sourceObject\n    convertUsing(dateToStringConverter)\n);\n\n// after\nconst dateToStringConverter: Converter<Date, string> = {\n    convert(source: Date): string {\n        return source.toDateString();\n    },\n};\ncreateMap(\n    mapper,\n    User,\n    UserDto,\n    forMember(\n        (d) => d.birthday,\n        // 2nd argument is required.\n        convertUsing(dateToStringConverter, (src) => src.birthday)\n    )\n);\n")),(0,o.kt)("p",null,"This breaking change encourages better ",(0,o.kt)("inlineCode",{parentName:"p"},"Converter")," usages. In the above example, it makes ",(0,o.kt)("inlineCode",{parentName:"p"},"dateToStringConverter")," easier to reuse. If you have use-cases that use the whole ",(0,o.kt)("inlineCode",{parentName:"p"},"sourceObject"),", consider using ",(0,o.kt)("inlineCode",{parentName:"p"},"mapFrom(Resolver)")," instead."),(0,o.kt)("h2",{id:"strategy-previously-plugin"},"Strategy (previously Plugin)"),(0,o.kt)("p",null,"Strategy can be customized with ",(0,o.kt)("inlineCode",{parentName:"p"},"MappingStrategyInitializerOptions")," which has the following interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface MappingStrategyInitializerOptions {\n    applyMetadata?: ApplyMetadata;\n    destinationConstructor?: DestinationConstructor;\n    preMap?<TSource extends Dictionary<TSource>>(source: TSource): TSource;\n    postMap?<\n        TSource extends Dictionary<TSource>,\n        TDestination extends Dictionary<TDestination>\n    >(\n        source: TSource,\n        destination: TDestination\n    ): TDestination;\n}\n\nconst mapper = createMapper({\n    strategyInitializer: classes({\n        applyMetadata, // customize how a Strategy applies the metadata to a model\n        destinationConstructor, // customize the default constructor of the Destination model\n        preMap, // customize what to do before a map happens\n        postMap, // customize what to do after a map happens\n    }),\n});\n")),(0,o.kt)("h2",{id:"automapperclasses"},(0,o.kt)("inlineCode",{parentName:"h2"},"@automapper/classes")),(0,o.kt)("h3",{id:"initializer"},"Initializer"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nconst mapper = createMapper({\n    pluginInitializer: classes, // no ()\n});\n\n// after\nconst mapper = createMapper({\n    strategyInitializer: classes(), // invoking\n});\n")),(0,o.kt)("h3",{id:"automap"},(0,o.kt)("inlineCode",{parentName:"h3"},"AutoMap")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"typeFn")," has been renamed to ",(0,o.kt)("inlineCode",{parentName:"li"},"type"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\n@AutoMap({ typeFn: () => User })\n\n// after\n@AutoMap({ type: () => User })\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If you only have ",(0,o.kt)("inlineCode",{parentName:"li"},"typeFn")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"AutoMapOptions"),", you can omit the object altogether")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\n@AutoMap({ typeFn: () => User })\n\n// after\n@AutoMap(() => User)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default ",(0,o.kt)("inlineCode",{parentName:"li"},"depth")," is set to 1 instead of 0."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"AutoMap")," now warns if it cannot infer the type of the property. If you have dynamic type like ",(0,o.kt)("inlineCode",{parentName:"li"},"any"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Record"),", or something similar, please configure the property via ",(0,o.kt)("inlineCode",{parentName:"li"},"forMember()"),"."),(0,o.kt)("li",{parentName:"ul"},"Array metadata is now required to be explicitly specified")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nexport class User {\n    @AutoMap({ typeFn: () => Address })\n    addresses: Address[];\n}\n\n// after\nexport class User {\n    @AutoMap(() => [Address])\n    addresses: Address[];\n}\n")),(0,o.kt)("h2",{id:"automapperpojos"},(0,o.kt)("inlineCode",{parentName:"h2"},"@automapper/pojos")),(0,o.kt)("h3",{id:"initializer-1"},"Initializer"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nconst mapper = createMapper({\n    pluginInitializer: pojos, // no ()\n});\n\n// after\nconst mapper = createMapper({\n    strategyInitializer: pojos(), // invoking\n});\n")),(0,o.kt)("h3",{id:"createmetadatamap"},(0,o.kt)("inlineCode",{parentName:"h3"},"createMetadataMap()")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Has been replaced with ",(0,o.kt)("inlineCode",{parentName:"li"},"PojosMetadataMap.create()"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Accepts ",(0,o.kt)("inlineCode",{parentName:"li"},"string | symbol")," for the key instead of just ",(0,o.kt)("inlineCode",{parentName:"li"},"string")),(0,o.kt)("li",{parentName:"ul"},"No longer accepts ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," for metadata."),(0,o.kt)("li",{parentName:"ul"},'No longer allows for "extending" previously created metadata. Explicit is better in the case of metadata.'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PojosMetadataMap.reset()")," has been added to clear all the stored metadata (useful for the testing environment)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\ncreateMetadataMap('SimpleUser', {\n    firstName: String,\n    lastName: String,\n});\ncreateMetadataMap('SimpleUserDto', 'SimpleUser', {\n    fullName: String,\n});\n\n// after\nPojosMetadataMap.create<SimpleUser>('SimpleUser', {\n    firstName: String,\n    lastName: String,\n});\nPojosMetadataMap.create<SimpleUserDto>('SimpleUserDto', {\n    firstName: String,\n    lastName: String,\n    fullName: String,\n});\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If you want to share ",(0,o.kt)("inlineCode",{parentName:"p"},"firstName")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"lastName"),", you can always make an object and spread it.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Array metadata is now required to be explicitly specified")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface User {\n    addresses: Address[];\n}\n\n// before\ncreateMetadataMap<User>('User', {\n    addresses: 'Address',\n});\n\n// after\nPojosMetadataMap.create<User>('User', {\n    addresses: ['Address'],\n});\n")),(0,o.kt)("h2",{id:"nestjs"},"NestJS"),(0,o.kt)("h3",{id:"automappermoduleforroot"},(0,o.kt)("inlineCode",{parentName:"h3"},"AutomapperModule.forRoot")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nAutomapperModule.forRoot({\n    singular: true,\n    options: [\n        {\n            pluginInitializer: classes,\n            namingConventions: new CamelCaseNamingConvention(),\n        },\n    ],\n    globalErrorHandler,\n    globalNamingConventions,\n});\n\nAutomapperModule.forRoot({\n    options: [\n        {\n            name: 'classes',\n            pluginInitializer: classes,\n        },\n        {\n            name: 'pojos',\n            pluginInitializer: pojos,\n        },\n    ],\n    globalErrorHandler,\n    globalNamingConventions: new CamelCaseNamingConvention(),\n});\n\n// after\nAutomapperModule.forRoot({\n    strategyInitializer: classes(),\n    namingConventions: new CamelCaseNamingConvention(),\n});\nAutomapperModule.forRoot(\n    [\n        {\n            name: 'classes',\n            strategyInitializer: classes(),\n        },\n        {\n            name: 'pojos',\n            strategyInitializer: pojos(),\n        },\n    ],\n    {\n        globalErrorHandler,\n        globalNamingConventions: new CamelCaseNamingConvention(),\n    }\n);\n")),(0,o.kt)("h3",{id:"automappermoduleforrootasync"},(0,o.kt)("inlineCode",{parentName:"h3"},"AutomapperModule.forRootAsync")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { EntityManager } from '@mikro-orm/mongodb';\n\nAutomapperModule.forRootAsync({\n    inject: [EntityManager],\n    useFactory: (em: EntityManager) => ({\n        strategyInitializer: classes({\n            destinationConstructor: (sourceObject, destinationIdentifier) =>\n                em.create(destinationIdentifier, {}),\n        }),\n    }),\n});\n")),(0,o.kt)("h3",{id:"automapperprofile"},(0,o.kt)("inlineCode",{parentName:"h3"},"AutomapperProfile")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"mapProfile")," has been changed to ",(0,o.kt)("inlineCode",{parentName:"li"},"get profile"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Injectable()\nexport class UserProfile extends AutomapperProfile {\n    constructor(@InjectMapper() mapper: Mapper) {\n        super(mapper);\n    }\n\n    // before\n    override mapProfile(): MappingProfile {\n        return (mapper) => {\n            mapper.createMap(/*...*/);\n        };\n    }\n\n    // after\n    override get profile(): MappingProfile {\n        return (mapper) => {\n            createMap(mapper /*...*/);\n        };\n    }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A new getter ",(0,o.kt)("inlineCode",{parentName:"li"},"get mappingConfigurations")," that returns a ",(0,o.kt)("inlineCode",{parentName:"li"},"MappingConfiguration[]")," to be passed to all ",(0,o.kt)("inlineCode",{parentName:"li"},"createMap()")," inside the Profile")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Injectable()\nexport class UserProfile extends AutomapperProfile {\n    constructor(@InjectMapper() mapper: Mapper) {\n        super(mapper);\n    }\n\n    get profile(): MappingProfile {\n        return (mapper) => {\n            createMap(mapper, UserEntity, UserDto);\n            createMap(mapper, UserEntity, UserInformationDto);\n            createMap(mapper, UserEntity, AuthUserDto);\n        };\n    }\n\n    protected get mappingConfigurations(): MappingConfiguration[] {\n        // the 3 createMap() above will get this `extend()`\n        return [extend(BaseEntity, BaseDto)];\n    }\n}\n")),(0,o.kt)("h3",{id:"mappipe"},(0,o.kt)("inlineCode",{parentName:"h3"},"MapPipe")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export class SomeController {\n    // before\n    @Post()\n    someMethod(@Body(MapPipe(UserDto, User)) dto: UserDto) {\n        /*..*/\n    }\n\n    // after\n    @Post()\n    someMethod(@Body(MapPipe(User, UserDto)) dto: UserDto) {\n        /*..*/\n    }\n}\n")),(0,o.kt)("h3",{id:"mapinterceptor"},(0,o.kt)("inlineCode",{parentName:"h3"},"MapInterceptor")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export class SomeController {\n    // before\n    @Get()\n    @UseInterceptors(MapInterceptor(UserDto, User))\n    get() {\n        /*...*/\n    }\n\n    // after\n    @Get()\n    @UseInterceptors(MapInterceptor(User, UserDto))\n    get() {\n        /*...*/\n    }\n}\n")))}u.isMDXComponent=!0}}]);